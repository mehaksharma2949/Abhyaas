// src/plugin.ts
import path from "path";
import { parse } from "@babel/parser";
import MagicString from "magic-string";

// src/utils.ts
var threeFiberElems = /* @__PURE__ */ new Set([
  // === 3D 核心对象 ===
  "object3D",
  "mesh",
  "batchedMesh",
  "instancedMesh",
  "scene",
  "sprite",
  "lOD",
  "skinnedMesh",
  "skeleton",
  "bone",
  "lineSegments",
  "lineLoop",
  "points",
  "group",
  // === 相机系统 ===
  "camera",
  "perspectiveCamera",
  "orthographicCamera",
  "cubeCamera",
  "arrayCamera",
  // === 几何体（Geometry）===
  "instancedBufferGeometry",
  "bufferGeometry",
  "boxBufferGeometry",
  "circleBufferGeometry",
  "coneBufferGeometry",
  "cylinderBufferGeometry",
  "dodecahedronBufferGeometry",
  "extrudeBufferGeometry",
  "icosahedronBufferGeometry",
  "latheBufferGeometry",
  "octahedronBufferGeometry",
  "planeBufferGeometry",
  "polyhedronBufferGeometry",
  "ringBufferGeometry",
  "shapeBufferGeometry",
  "sphereBufferGeometry",
  "tetrahedronBufferGeometry",
  "torusBufferGeometry",
  "torusKnotBufferGeometry",
  "tubeBufferGeometry",
  "wireframeGeometry",
  "tetrahedronGeometry",
  "octahedronGeometry",
  "icosahedronGeometry",
  "dodecahedronGeometry",
  "polyhedronGeometry",
  "tubeGeometry",
  "torusKnotGeometry",
  "torusGeometry",
  "sphereGeometry",
  "ringGeometry",
  "planeGeometry",
  "latheGeometry",
  "shapeGeometry",
  "extrudeGeometry",
  "edgesGeometry",
  "coneGeometry",
  "cylinderGeometry",
  "circleGeometry",
  "boxGeometry",
  "capsuleGeometry",
  // === 材质系统（Materials）===
  "material",
  "shadowMaterial",
  "spriteMaterial",
  "rawShaderMaterial",
  "shaderMaterial",
  "pointsMaterial",
  "meshPhysicalMaterial",
  "meshStandardMaterial",
  "meshPhongMaterial",
  "meshToonMaterial",
  "meshNormalMaterial",
  "meshLambertMaterial",
  "meshDepthMaterial",
  "meshDistanceMaterial",
  "meshBasicMaterial",
  "meshMatcapMaterial",
  "lineDashedMaterial",
  "lineBasicMaterial",
  "primitive",
  // === 光源系统（Lights）===
  "light",
  "spotLightShadow",
  "spotLight",
  "pointLight",
  "rectAreaLight",
  "hemisphereLight",
  "directionalLightShadow",
  "directionalLight",
  "ambientLight",
  "lightShadow",
  "ambientLightProbe",
  "hemisphereLightProbe",
  "lightProbe",
  // === 辅助对象（Helpers）===
  "spotLightHelper",
  "skeletonHelper",
  "pointLightHelper",
  "hemisphereLightHelper",
  "gridHelper",
  "polarGridHelper",
  "directionalLightHelper",
  "cameraHelper",
  "boxHelper",
  "box3Helper",
  "planeHelper",
  "arrowHelper",
  "axesHelper",
  // === 纹理系统（Textures）===
  "texture",
  "videoTexture",
  "dataTexture",
  "dataTexture3D",
  "compressedTexture",
  "cubeTexture",
  "canvasTexture",
  "depthTexture",
  // === 数学对象（Math Objects）===
  "raycaster",
  "vector2",
  "vector3",
  "vector4",
  "euler",
  "matrix3",
  "matrix4",
  "quaternion",
  // === 缓冲属性（Buffer Attributes）===
  "bufferAttribute",
  "float16BufferAttribute",
  "float32BufferAttribute",
  "float64BufferAttribute",
  "int8BufferAttribute",
  "int16BufferAttribute",
  "int32BufferAttribute",
  "uint8BufferAttribute",
  "uint16BufferAttribute",
  "uint32BufferAttribute",
  "instancedBufferAttribute",
  // === 其他 Three.js 对象 ===
  "audioListener",
  "positionalAudio",
  "color",
  "fog",
  "fogExp2",
  "shape",
  "colorShiftMaterial"
]);
function shouldTagElement(elementName, threeDreiImportedElements, threeDreiNamespaces) {
  if (threeFiberElems.has(elementName)) {
    return false;
  }
  if (threeDreiImportedElements.has(elementName)) {
    return false;
  }
  if (elementName.includes(".")) {
    const namespace = elementName.split(".")[0];
    if (threeDreiNamespaces.has(namespace)) {
      return false;
    }
  }
  return true;
}
function isMapCall(node) {
  if (node.type !== "CallExpression") {
    return false;
  }
  const callee = node.callee;
  if (callee.type !== "MemberExpression") {
    return false;
  }
  if (callee.property.type !== "Identifier" || callee.property.name !== "map") {
    return false;
  }
  if (node.arguments.length === 0) {
    return false;
  }
  const callback = node.arguments[0];
  const isFunction = callback.type === "ArrowFunctionExpression" || callback.type === "FunctionExpression";
  return isFunction;
}
function extractMapContext(node, level = 0) {
  const callback = node.arguments[0];
  const params = callback.params || [];
  const id = `map-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const itemParamName = params[0]?.name;
  const indexParamName = params[1]?.name;
  let sourceName;
  if (node.callee.object?.type === "Identifier") {
    sourceName = node.callee.object.name;
  }
  return {
    id,
    level,
    hasIndex: params.length > 1,
    indexParamName,
    itemParamName,
    sourceName
  };
}

// src/plugin.ts
var defaultOptions = {
  enabled: true,
  // 默认启用
  enableInProduction: false,
  // 生产环境默认禁用，避免泄露源码信息
  exclude: ["node_modules"],
  // 排除第三方库
  extensions: [".jsx", ".tsx"],
  // 只处理 React 文件
  prefix: "data-devv",
  // 自定义前缀，避免属性冲突
  includeLegacyAttributes: true
  // 兼容旧版本，方便迁移
};
function componentTagger(options = {}) {
  const config = { ...defaultOptions, ...options };
  const isProd = process.env.IS_PROD === "true";
  const isEnabled = config.enabled && (!isProd || config.enableInProduction);
  const validExtensions = new Set(config.extensions);
  const cwd = process.cwd();
  const stats = {
    totalFiles: 0,
    processedFiles: 0,
    totalElements: 0
  };
  return {
    name: "vite-plugin-devv-tagger",
    // enforce: "pre" 关键配置
    // 确保此插件在其他插件（如 React 插件）之前运行
    // 这样我们处理的是原始 JSX 代码，而不是转换后的 JS
    enforce: "pre",
    /**
     * transform 钩子 - Vite 插件的核心
     * 
     * 执行时机：每个文件被导入时调用
     * 作用：修改文件内容后返回
     * 
     * @param code 文件的源代码字符串
     * @param id 文件的绝对路径
     * @returns 转换后的代码和 source map
     */
    async transform(code, id) {
      if (!isEnabled) {
        return null;
      }
      const shouldProcess = validExtensions.has(path.extname(id)) && !config.exclude?.some((pattern) => id.includes(pattern));
      if (!shouldProcess) {
        return null;
      }
      stats.totalFiles++;
      const relativePath = path.relative(cwd, id);
      try {
        const parserOptions = {
          sourceType: "module",
          // ES6 模块
          plugins: ["jsx", "typescript"]
          // 支持 JSX 和 TS
        };
        const ast = parse(code, parserOptions);
        const magicString = new MagicString(code);
        let changedElementsCount = 0;
        let currentElement = null;
        const mapContextStack = [];
        let currentMapContext = null;
        const threeDreiImportedElements = /* @__PURE__ */ new Set();
        const threeDreiNamespaces = /* @__PURE__ */ new Set();
        const { walk } = await import("estree-walker");
        walk(ast.program, {
          enter(node) {
            if (node.type === "ImportDeclaration") {
              const source = node.source?.value;
              if (typeof source === "string" && source.includes("@react-three/drei")) {
                node.specifiers.forEach((spec) => {
                  if (spec.type === "ImportSpecifier") {
                    threeDreiImportedElements.add(spec.local.name);
                  } else if (spec.type === "ImportNamespaceSpecifier") {
                    threeDreiNamespaces.add(spec.local.name);
                  }
                });
              }
            }
          }
        });
        walk(ast.program, {
          enter(node) {
            if (isMapCall(node)) {
              const mapContext = extractMapContext(node, mapContextStack.length);
              mapContextStack.push(mapContext);
              currentMapContext = mapContext;
            }
            if (node.type === "JSXElement") {
              currentElement = node;
            }
            if (node.type === "JSXOpeningElement") {
              const jsxNode = node;
              let elementName;
              if (jsxNode.name.type === "JSXIdentifier") {
                elementName = jsxNode.name.name;
              } else if (jsxNode.name.type === "JSXMemberExpression") {
                const memberExpr = jsxNode.name;
                elementName = `${memberExpr.object?.name}.${memberExpr.property?.name}`;
              } else {
                return;
              }
              if (elementName === "Fragment" || elementName === "React.Fragment") {
                return;
              }
              let keyAttribute = null;
              const attributes = jsxNode.attributes.reduce((acc, attr) => {
                if (attr.type === "JSXAttribute") {
                  if (attr.name.name === "key") {
                    keyAttribute = attr;
                  }
                  if (attr.value?.type === "StringLiteral") {
                    acc[attr.name.name] = attr.value.value;
                  } else if (attr.value?.type === "JSXExpressionContainer" && attr.value.expression.type === "StringLiteral") {
                    acc[attr.name.name] = attr.value.expression.value;
                  }
                }
                return acc;
              }, {});
              let textContent = "";
              if (currentElement && currentElement.children) {
                textContent = currentElement.children.map((child) => {
                  if (child.type === "JSXText") {
                    return child.value.trim();
                  } else if (child.type === "JSXExpressionContainer") {
                    if (child.expression.type === "StringLiteral") {
                      return child.expression.value;
                    }
                  }
                  return "";
                }).filter(Boolean).join(" ").trim();
              }
              const content = {};
              if (textContent) {
                content.text = textContent;
              }
              if (attributes.placeholder) {
                content.placeholder = attributes.placeholder;
              }
              if (attributes.className) {
                content.className = attributes.className;
              }
              const line = jsxNode.loc?.start?.line ?? 0;
              const col = jsxNode.loc?.start?.column ?? 0;
              const dataComponentId = `${relativePath}:${line}:${col}`;
              let keyExpression = "";
              if (currentMapContext && keyAttribute && keyAttribute.value) {
                const keyStart = keyAttribute.value.start;
                const keyEnd = keyAttribute.value.end;
                if (keyStart !== void 0 && keyEnd !== void 0) {
                  keyExpression = code.slice(keyStart, keyEnd);
                }
              }
              const fileName = path.basename(id);
              const shouldTag = shouldTagElement(
                elementName,
                threeDreiImportedElements,
                threeDreiNamespaces
              );
              if (shouldTag) {
                const uniqueId = `${relativePath}:${line}:${col}`;
                const dataAttrs = ` ${config.prefix}-id="${uniqueId}" ${config.prefix}-file="${relativePath}" ${config.prefix}-line="${line}" ${config.prefix}-column="${col}"`;
                magicString.appendLeft(jsxNode.name.end ?? 0, dataAttrs);
                changedElementsCount++;
              }
            }
          },
          leave(node) {
            if (isMapCall(node)) {
              mapContextStack.pop();
              currentMapContext = mapContextStack.length > 0 ? mapContextStack[mapContextStack.length - 1] : null;
            }
          }
        });
        stats.processedFiles++;
        stats.totalElements += changedElementsCount;
        return {
          // 转换后的代码字符串
          code: magicString.toString(),
          // Source Map：保持调试时的代码映射关系
          // hires: true 生成高精度 source map
          map: magicString.generateMap({ hires: true })
        };
      } catch (error) {
        console.error(`[devv-tagger] \u5904\u7406\u6587\u4EF6 ${relativePath} \u65F6\u51FA\u9519:`, error);
        stats.processedFiles++;
        return null;
      }
    },
    /**
     * buildEnd 钩子 - 构建结束时调用
     * 静默模式，不输出统计信息
     */
    buildEnd() {
    }
  };
}
export {
  componentTagger,
  componentTagger as default
};
